<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Melon Bolg</title>
    <link>https://melonyii.github.io/blog/</link>
    <description>Recent content on Melon Bolg</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 08 Feb 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://melonyii.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>将blog从jekyll迁移至hugo</title>
      <link>https://melonyii.github.io/blog/post/2018-02-09-%E8%BF%81%E7%A7%BBblog/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2018-02-09-%E8%BF%81%E7%A7%BBblog/</guid>
      <description> 之前的blog一直在写，但是没有更新。最近想更新的时候才想起来jekyll环境是在我另一台电脑上的。因此将blog换到环境简便的hugo
Usage hugo  </description>
    </item>
    
    <item>
      <title>python meta 探索</title>
      <link>https://melonyii.github.io/blog/post/2017-12-15-django-meta/</link>
      <pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2017-12-15-django-meta/</guid>
      <description>最开始是想了解一下Django框架的ORM是如何实现的。发现其实涉及到的一个重要知识点就是meta。本人python并没有非常系统的学习，于是决定探一探python的meta。
引子 Python 中的一切都是对象，包括类也是对象。大家有没有好奇，那类的类是什么呢？代码告诉你。
a = 1 a.__class__ # int type(a) # int class A(object): pass A.__class__ # type A.__class__.__class__ # type type(A) # type  控制台中输出的type和查看类型的type的功能可不一样。类的类其实就是元类。
type 能力 type除了我们常用的返回对象的类型外，还有一个功能。它能动态的创建类。
type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)  以下两段代码是等价的，
class MyShinyClass(object): pass MyShinyClass = type(&#39;MyShinyClass&#39;, (), {})  当我们使用 class 来创建类的时候，Python 实际上就是用 type 来创建类的，这种方式主要是通过元类(meta class)来实现的。
什么是 meta class 在创建类的时候，有一个特殊的属性(__metaclass__)，可以用函数或者类来指定元类。
class Foo(object): __metaclass__ = something  上述代码会使用something来创建类。
class Foo(Bar): pass  如果是上述代码创建类，python将做如下动作：
 Foo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。 如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。 如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。 如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。  自定义元类 我们自定义元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。</description>
    </item>
    
    <item>
      <title>通过Docker部署Flask和Django应用实践</title>
      <link>https://melonyii.github.io/blog/post/2017-08-31-docker-%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2017-08-31-docker-%E5%AE%9E%E8%B7%B5/</guid>
      <description>这里假设，你已经有一个flask或者django项目，并且能够在主机上面成功部署。现在你想迁移到docker环境中。这篇文章可以给你一定的参考。我们在docker内部使用supervisor管理进程，当应用crash时，能够及时重启。supervisor简单教程及介绍(cn)。
日志 由于使用了supervisor，所以uwsgi，nginx日志都会在/var/log/supervisor/目录下
Flask + uwsgi + Nginx nginx配置文件[nginx.conf] # configuration of the server server { # the port your site will be served on, default_server indicates that this server block # is the block to use if no blocks match the server_name listen 80; server_name yourhost; access_log /var/log/nginx/xx.log; # the domain name it will serve for charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Finally, send all non-media requests to the Django server.</description>
    </item>
    
    <item>
      <title>在开发中使用fetch跨域中碰到的问题</title>
      <link>https://melonyii.github.io/blog/post/2017-02-14-fetch-%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Tue, 14 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2017-02-14-fetch-%E8%B7%A8%E5%9F%9F/</guid>
      <description> CORS（Cross-origin resource sharing） “跨域资源共享”
后端接口中，需要进行权限校验，分别放在了headers中的 authorization 与Content-Type中。 当进行跨域访问的时候，发现这两者都不见了。正常的头会因为跨域影响。
fetch.js 常见坑  Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: &amp;lsquo;include&amp;rsquo;}) 如果是非简单请求跨域时使用了mode: &#39;cors&#39;，所有的头 都会加上Access-Control-xx。 请求方法是put，或者Content-Type字段的类型是application/json 都是非简单请求 如果是简单请求， 其实在浏览器发出请求的时候，是不需要做多余操作的，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。  最后说一句，去用axios吧~~
参考  跨域——CORS 详解 fetch.js 传统 Ajax 已死，Fetch 永生 跨域资源共享 CORS 详解  </description>
    </item>
    
    <item>
      <title>Sequel 使用中碰到的一些问题</title>
      <link>https://melonyii.github.io/blog/post/2017-02-08-sequel%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2017-02-08-sequel%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <description>在使用Sequel连接数据库的时候，采用ssh方式连接的过程中，碰到Permissions 0644 for &#39;/Users/melonyii/Documents/pem/xxx.pem&#39; are too open.,显然是没有权限了。由于都是在软件内部执行的，不能使用超管权限所以只能修改这份文件的权限了。chmod 400 xxx.pem（读取权限）</description>
    </item>
    
    <item>
      <title>datadog 监控docker中Django应用</title>
      <link>https://melonyii.github.io/blog/post/2018-01-26-datadog-django/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2018-01-26-datadog-django/</guid>
      <description>使用datadog中的apm监控容器中django应用 由于最近工作需要，了解了一下Datadog。照着文档对cassandraDjango进行了监控。看了一下这方面的中文教程基本没有，并且还是有一些坑，记录一下。这篇博客主要是对于Django。
概念 简答介绍下Datadog中的一些概念。
部署 Datadog Agent是我们获取数据的服务。</description>
    </item>
    
    <item>
      <title>记一次python apscheduler 内存泄漏</title>
      <link>https://melonyii.github.io/blog/post/2018-01-05-python-apscheduler-memory-leak/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2018-01-05-python-apscheduler-memory-leak/</guid>
      <description> 记一次python apscheduler 内存泄漏 场景 </description>
    </item>
    
    <item>
      <title>记一次webpack 打包优化</title>
      <link>https://melonyii.github.io/blog/post/2018-01-03-webpack-optimize/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2018-01-03-webpack-optimize/</guid>
      <description>记一次webpack 打包优化 场景 我们公司所有产品的后台都是在一个前端项目中，so 我们的项目越来越大。从开始打包的几个文件，几分钟到后来几百个文件，20多分钟。这个当然不能忍了。 目前打包打包出来有201个文件，
优化前 time: 1000s~1200s total size: 112291323 B
| size | file | | &amp;ndash; | &amp;ndash; | |1405578 | 011d3b0dc115e2ef0dae.async.js| |569754 | 05aa3325b981700333d7.async.js| |1048157 | 05e5fc19fff54bb524c8.async.js| |395192 | 0636dedd9830ecc2eefe.async.js| |367873 | 07885f481aebbad1b60d.async.js| |316387 | 07c4630feb88a55435f1.async.js| |449770 | 080ade662b7adff1346e.async.js| |582824 | 08762aba4c3d4aca77df.css| |557437 | 0882b9cfbcff727e0717.async.js| |458852 | 0a379ca4fde06b2d6442.async.js| |553569 | 0b7c474e33141d179b31.async.js| |283808 | 0ce98b914f462dd6860d.async.js| |464103 | 0ddb380dee6409ef3e8d.async.js| |364696 | 0ee07b26b71bf7fa7679.async.js| |1002908 | 0f09b312ef1090db9fff.async.js| |1051409 | 148f7d7dde6bebc6144b.</description>
    </item>
    
  </channel>
</rss>