<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Melon Bolg</title>
    <link>https://melonyii.github.io/blog/</link>
    <description>Recent content on Melon Bolg</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 08 Feb 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://melonyii.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>将blog从jekyll迁移至hugo</title>
      <link>https://melonyii.github.io/blog/post/2018-02-09-%E8%BF%81%E7%A7%BBblog/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2018-02-09-%E8%BF%81%E7%A7%BBblog/</guid>
      <description> 之前的blog一直在写，但是没有更新。最近想更新的时候才想起来jekyll环境是在我另一台电脑上的。因此将blog换到环境简便的hugo
Usage hugo  </description>
    </item>
    
    <item>
      <title>通过Docker部署Flask和Django应用实践</title>
      <link>https://melonyii.github.io/blog/post/2017-08-31-docker-%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2017-08-31-docker-%E5%AE%9E%E8%B7%B5/</guid>
      <description>这里假设，你已经有一个flask或者django项目，并且能够在主机上面成功部署。现在你想迁移到docker环境中。这篇文章可以给你一定的参考。我们在docker内部使用supervisor管理进程，当应用crash时，能够及时重启。supervisor简单教程及介绍(cn)。
日志 由于使用了supervisor，所以uwsgi，nginx日志都会在/var/log/supervisor/目录下
Flask + uwsgi + Nginx nginx配置文件[nginx.conf] # configuration of the server server { # the port your site will be served on, default_server indicates that this server block # is the block to use if no blocks match the server_name listen 80; server_name yourhost; access_log /var/log/nginx/xx.log; # the domain name it will serve for charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Finally, send all non-media requests to the Django server.</description>
    </item>
    
    <item>
      <title>在开发中使用fetch跨域中碰到的问题</title>
      <link>https://melonyii.github.io/blog/post/2017-02-14-fetch-%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Tue, 14 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2017-02-14-fetch-%E8%B7%A8%E5%9F%9F/</guid>
      <description> CORS（Cross-origin resource sharing） “跨域资源共享”
后端接口中，需要进行权限校验，分别放在了headers中的 authorization 与Content-Type中。 当进行跨域访问的时候，发现这两者都不见了。正常的头会因为跨域影响。
fetch.js 常见坑  Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: &amp;lsquo;include&amp;rsquo;}) 如果是非简单请求跨域时使用了mode: &#39;cors&#39;，所有的头 都会加上Access-Control-xx。 请求方法是put，或者Content-Type字段的类型是application/json 都是非简单请求 如果是简单请求， 其实在浏览器发出请求的时候，是不需要做多余操作的，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。  最后说一句，去用axios吧~~
参考  跨域——CORS 详解 fetch.js 传统 Ajax 已死，Fetch 永生 跨域资源共享 CORS 详解  </description>
    </item>
    
    <item>
      <title>Sequel 使用中碰到的一些问题</title>
      <link>https://melonyii.github.io/blog/post/2017-02-08-sequel%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2017-02-08-sequel%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <description>在使用Sequel连接数据库的时候，采用ssh方式连接的过程中，碰到Permissions 0644 for &#39;/Users/melonyii/Documents/pem/xxx.pem&#39; are too open.,显然是没有权限了。由于都是在软件内部执行的，不能使用超管权限所以只能修改这份文件的权限了。chmod 400 xxx.pem（读取权限）</description>
    </item>
    
    <item>
      <title>datadog 监控docker中Django应用</title>
      <link>https://melonyii.github.io/blog/post/2018-01-26-datadog-django/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2018-01-26-datadog-django/</guid>
      <description>使用datadog中的apm监控容器中django应用 由于最近工作需要，了解了一下Datadog。照着文档对cassandraDjango进行了监控。看了一下这方面的中文教程基本没有，并且还是有一些坑，记录一下。这篇博客主要是对于Django。
概念 简答介绍下Datadog中的一些概念。
部署 Datadog Agent是我们获取数据的服务。</description>
    </item>
    
    <item>
      <title>django meta 探索</title>
      <link>https://melonyii.github.io/blog/post/2017-12-15-django-meta/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2017-12-15-django-meta/</guid>
      <description></description>
    </item>
    
    <item>
      <title>从dva-1.x antd-2.x react-15.x到dva-2.x antd-3.x react-16.x</title>
      <link>https://melonyii.github.io/blog/post/2017-12-07-viva-admin-to-antp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2017-12-07-viva-admin-to-antp/</guid>
      <description> 从react-admin到Ant Design Pro 本次变化，也是整体技术栈的升级 component, routes 变化 在之前的react-admin中，components承接的是route的详情化。而现在ADP的component则是用来存放公共组件的地方
数据流 虽然两者运用的都是redux的方式，但是在实际处理的时候还是有比较大的区别。我们拿获取列表数据，并且能够filter进行搜索举个例子。
react-admin 发起action时候需要先在route中封装getlistfunc。接着在components 中使用
ADP </description>
    </item>
    
    <item>
      <title>记一次python apscheduler 内存泄漏</title>
      <link>https://melonyii.github.io/blog/post/2018-01-05-python-apscheduler-memory-leak/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2018-01-05-python-apscheduler-memory-leak/</guid>
      <description> 记一次python apscheduler 内存泄漏 场景 </description>
    </item>
    
    <item>
      <title>记一次webpack 打包优化</title>
      <link>https://melonyii.github.io/blog/post/2018-01-03-webpack-optimize/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://melonyii.github.io/blog/post/2018-01-03-webpack-optimize/</guid>
      <description>记一次webpack 打包优化 场景 我们公司所有产品的后台都是在一个前端项目中，so 我们的项目越来越大。从开始打包的几个文件，几分钟到后来几百个文件，20多分钟。这个当然不能忍了。 目前打包打包出来有201个文件，
优化前 time: 1000s~1200s total size: 112291323 B
| size | file | | &amp;ndash; | &amp;ndash; | |1405578 | 011d3b0dc115e2ef0dae.async.js| |569754 | 05aa3325b981700333d7.async.js| |1048157 | 05e5fc19fff54bb524c8.async.js| |395192 | 0636dedd9830ecc2eefe.async.js| |367873 | 07885f481aebbad1b60d.async.js| |316387 | 07c4630feb88a55435f1.async.js| |449770 | 080ade662b7adff1346e.async.js| |582824 | 08762aba4c3d4aca77df.css| |557437 | 0882b9cfbcff727e0717.async.js| |458852 | 0a379ca4fde06b2d6442.async.js| |553569 | 0b7c474e33141d179b31.async.js| |283808 | 0ce98b914f462dd6860d.async.js| |464103 | 0ddb380dee6409ef3e8d.async.js| |364696 | 0ee07b26b71bf7fa7679.async.js| |1002908 | 0f09b312ef1090db9fff.async.js| |1051409 | 148f7d7dde6bebc6144b.</description>
    </item>
    
  </channel>
</rss>